/**
 * Safe EIP-1271 Signer for Polymarket CLOB
 *
 * This creates a signer that uses a Gnosis Safe to sign orders via EIP-1271,
 * allowing the Safe to maintain custody of USDC while making trades.
 *
 * Key features:
 * - Signs with Safe contract (EIP-1271) not EOA
 * - maker = signer = Safe address (preserves custody)
 * - Uses signatureType = 3 (POLY_1271) for Polymarket
 */

import Safe from '@safe-global/protocol-kit'
import { ethers } from 'ethers'

export class SafeEIP1271Signer extends ethers.Wallet {
  private safeSDK: Safe | null = null
  private safeAddress: string
  private _rpcProvider: ethers.Provider | null = null

  constructor(operatorKey: string, safeAddress: string) {
    super(operatorKey)
    this.safeAddress = safeAddress

    // Override the address property to return Safe address
    // This is critical: maker = signer = Safe for EIP-1271 validation
    Object.defineProperty(this, 'address', {
      get: () => this.safeAddress,
      enumerable: true,
      configurable: false,
    })
  }

  /**
   * Initialize Safe SDK with provider
   * The operator (EOA) must be an owner of the Safe
   */
  async initializeSafe(provider: ethers.Provider | string): Promise<void> {
    try {
      // Store provider reference
      if (typeof provider === 'string') {
        this._rpcProvider = new ethers.JsonRpcProvider(provider)
      } else {
        this._rpcProvider = provider
      }

      // Get RPC URL from provider
      let rpcUrl: string
      if (typeof provider === 'string') {
        rpcUrl = provider
      } else {
        // Extract RPC URL from JsonRpcProvider
        const jsonRpcProvider = provider as ethers.JsonRpcProvider
        // @ts-ignore - accessing private _getConnection method
        const connection = jsonRpcProvider._getConnection?.() || {}
        rpcUrl = connection.url || process.env.POLYGON_RPC_URL || 'https://polygon-mainnet.g.alchemy.com/v2/demo'
      }

      // Initialize Safe SDK with RPC URL and operator key
      // The operator must be one of the Safe owners to sign messages
      this.safeSDK = await Safe.init({
        provider: rpcUrl,
        signer: this.privateKey,
        safeAddress: this.safeAddress,
      })

      console.log(`[SafeSigner] Safe SDK initialized`)
      console.log(`[SafeSigner] Safe address: ${this.safeAddress}`)
      console.log(`[SafeSigner] Operator: ${await super.getAddress()}`)
    } catch (error: any) {
      console.error('[SafeSigner] Failed to initialize Safe SDK:', error)
      throw new Error(`Safe SDK initialization failed: ${error.message}`)
    }
  }

  /**
   * Override signTypedData to use Safe's EIP-1271 signing
   *
   * This produces a contract signature that can be verified via EIP-1271:
   * 1. Hash the EIP-712 typed data
   * 2. Get Safe owners to sign the message hash
   * 3. Encode the signature in EIP-1271 format
   */
  async signTypedData(
    domain: ethers.TypedDataDomain,
    types: Record<string, ethers.TypedDataField[]>,
    value: Record<string, any>
  ): Promise<string> {
    if (!this.safeSDK) {
      throw new Error('Safe SDK not initialized. Call initializeSafe() first.')
    }

    try {
      // Construct EIP-712 hash from typed data
      const messageHash = ethers.TypedDataEncoder.hash(domain, types, value)

      console.log('[SafeSigner] Creating Safe EIP-1271 signature:')
      console.log(`[SafeSigner]   Safe: ${this.safeAddress}`)
      console.log(`[SafeSigner]   Hash: ${messageHash}`)

      // Create Safe message for signing
      const safeMessage = this.safeSDK.createMessage(messageHash)

      // Sign with Safe (this uses the operator as one of the owners)
      // For a 1-of-N Safe, the operator's signature is sufficient
      // For M-of-N Safes, this would require collecting M signatures
      const signedMessage = await this.safeSDK.signMessage(safeMessage)

      console.log('[SafeSigner] Message signed by Safe owners')

      // Encode signatures in the format expected by Safe
      // This returns the encoded signature that includes:
      // - Signature data for each signer
      // - Properly formatted for EIP-1271 verification
      const encodedSignature = signedMessage.encodedSignatures()

      console.log(`[SafeSigner] Encoded signature length: ${encodedSignature.length}`)

      return encodedSignature
    } catch (error: any) {
      console.error('[SafeSigner] Error signing with Safe:', error)
      throw new Error(`Safe signing failed: ${error.message}`)
    }
  }

  /**
   * Add v5 compatibility (for Polymarket SDK)
   * The SDK calls this method instead of signTypedData
   */
  async _signTypedData(
    domain: any,
    types: any,
    value: any
  ): Promise<string> {
    return this.signTypedData(domain, types, value)
  }

  /**
   * Override address to return Safe address (not operator address)
   * This is critical: maker = signer = Safe
   *
   * When the CLOB validates the order:
   * - It sees signer = Safe address
   * - It calls Safe.isValidSignature(hash, signature) via EIP-1271
   * - Safe validates that its owners signed the hash
   */
  get address(): string {
    return this.safeAddress
  }

  /**
   * Get the operator (EOA) address
   * This is the actual wallet signing on behalf of the Safe
   */
  async getOperatorAddress(): Promise<string> {
    return super.getAddress()
  }

  /**
   * Check if Safe SDK is initialized
   */
  isInitialized(): boolean {
    return this.safeSDK !== null
  }
}
